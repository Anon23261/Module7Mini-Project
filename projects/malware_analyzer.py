#!/usr/bin/env python3

import os
import sys
import time
import json
import hashlib
import logging
import yara
import magic
import pefile
import requests
import ssdeep
import threading
import subprocess
from typing import Dict, List, Optional, Tuple, Union
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor
import pandas as pd
from rich.console import Console
from rich.table import Table
from rich.progress import Progress

@dataclass
class FileInfo:
    path: str
    size: int
    md5: str
    sha1: str
    sha256: str
    ssdeep_hash: str
    mime_type: str
    file_type: str
    creation_time: float
    modification_time: float
    access_time: float

@dataclass
class PEInfo:
    is_pe: bool
    machine_type: str = ""
    compile_time: str = ""
    entry_point: str = ""
    sections: List[Dict] = None
    imports: Dict[str, List[str]] = None
    exports: List[str] = None
    signatures: List[Dict] = None
    packer_detection: List[str] = None

@dataclass
class NetworkActivity:
    timestamp: str
    protocol: str
    source_ip: str
    source_port: int
    destination_ip: str
    destination_port: int
    data_size: int
    payload_hash: str

@dataclass
class BehaviorAnalysis:
    file_operations: List[Dict]
    registry_operations: List[Dict]
    process_operations: List[Dict]
    network_connections: List[NetworkActivity]
    api_calls: List[Dict]
    suspicious_behaviors: List[str]

class MalwareAnalyzer:
    def __init__(self, target_path: str, output_dir: str, verbose: bool = False):
        self.target_path = Path(target_path)
        self.output_dir = Path(output_dir)
        self.verbose = verbose
        self.console = Console()
        self.setup_logging()
        self.load_yara_rules()
        
    def setup_logging(self):
        """Configure logging with detailed formatting"""
        log_file = self.output_dir / "malware_analysis.log"
        logging.basicConfig(
            level=logging.DEBUG if self.verbose else logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger("MalwareAnalyzer")

    def load_yara_rules(self):
        """Load YARA rules from rules directory"""
        rules_dir = Path(__file__).parent / "rules"
        if not rules_dir.exists():
            rules_dir.mkdir(parents=True)
            self._download_yara_rules()
        
        try:
            self.rules = yara.compile(filepaths={
                f.stem: str(f) for f in rules_dir.glob("*.yar")
            })
        except Exception as e:
            self.logger.error(f"Failed to load YARA rules: {e}")
            self.rules = None

    def _download_yara_rules(self):
        """Download common YARA rules from various sources"""
        rule_sources = [
            "https://github.com/Yara-Rules/rules/raw/master/malware/MALW_AZORULT.yar",
            "https://github.com/Yara-Rules/rules/raw/master/malware/MALW_EMOTET.yar",
            "https://github.com/Yara-Rules/rules/raw/master/malware/MALW_Ransomware.yar"
        ]
        
        rules_dir = Path(__file__).parent / "rules"
        for url in rule_sources:
            try:
                response = requests.get(url)
                if response.status_code == 200:
                    rule_file = rules_dir / f"{hashlib.md5(url.encode()).hexdigest()}.yar"
                    rule_file.write_text(response.text)
            except Exception as e:
                self.logger.warning(f"Failed to download rule from {url}: {e}")

    def analyze_file(self, file_path: str) -> Dict:
        """Perform comprehensive analysis of a file"""
        self.logger.info(f"Starting analysis of {file_path}")
        
        results = {
            "file_info": self._get_file_info(file_path),
            "yara_matches": self._scan_with_yara(file_path),
            "pe_analysis": self._analyze_pe(file_path),
            "strings_analysis": self._analyze_strings(file_path),
            "behavior_analysis": self._analyze_behavior(file_path),
            "network_analysis": self._analyze_network_activity(file_path),
            "threat_intelligence": self._check_threat_intelligence(file_path),
            "analysis_time": datetime.now().isoformat()
        }
        
        self._generate_report(results)
        return results

    def _get_file_info(self, file_path: str) -> FileInfo:
        """Get basic file information"""
        file_path = Path(file_path)
        file_stats = file_path.stat()
        
        with open(file_path, "rb") as f:
            content = f.read()
            md5_hash = hashlib.md5(content).hexdigest()
            sha1_hash = hashlib.sha1(content).hexdigest()
            sha256_hash = hashlib.sha256(content).hexdigest()
            ssdeep_hash = ssdeep.hash(content)
        
        return FileInfo(
            path=str(file_path),
            size=file_stats.st_size,
            md5=md5_hash,
            sha1=sha1_hash,
            sha256=sha256_hash,
            ssdeep_hash=ssdeep_hash,
            mime_type=magic.from_file(str(file_path), mime=True),
            file_type=magic.from_file(str(file_path)),
            creation_time=file_stats.st_ctime,
            modification_time=file_stats.st_mtime,
            access_time=file_stats.st_atime
        )

    def _scan_with_yara(self, file_path: str) -> List[Dict]:
        """Scan file with YARA rules"""
        if not self.rules:
            return []
        
        try:
            matches = self.rules.match(file_path)
            return [
                {
                    "rule_name": match.rule,
                    "tags": match.tags,
                    "strings": [
                        {
                            "identifier": str_match.identifier,
                            "offset": str_match.offset,
                            "data": str_match.data
                        }
                        for str_match in match.strings
                    ],
                    "meta": match.meta
                }
                for match in matches
            ]
        except Exception as e:
            self.logger.error(f"YARA scan failed: {e}")
            return []

    def _analyze_pe(self, file_path: str) -> PEInfo:
        """Analyze PE file structure and characteristics"""
        try:
            pe = pefile.PE(file_path)
            sections = []
            imports = {}
            exports = []
            
            # Analyze sections
            for section in pe.sections:
                section_info = {
                    "name": section.Name.decode().rstrip('\x00'),
                    "virtual_address": hex(section.VirtualAddress),
                    "virtual_size": hex(section.Misc_VirtualSize),
                    "raw_size": hex(section.SizeOfRawData),
                    "entropy": section.get_entropy()
                }
                sections.append(section_info)
            
            # Analyze imports
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                for entry in pe.DIRECTORY_ENTRY_IMPORT:
                    imports[entry.dll.decode()] = [
                        imp.name.decode() if imp.name else hex(imp.ordinal)
                        for imp in entry.imports
                    ]
            
            # Analyze exports
            if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
                exports = [
                    exp.name.decode() if exp.name else hex(exp.ordinal)
                    for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols
                ]
            
            # Check for signatures
            signatures = self._analyze_signatures(pe)
            
            # Detect packers
            packers = self._detect_packers(pe)
            
            return PEInfo(
                is_pe=True,
                machine_type=pefile.MACHINE_TYPE[pe.FILE_HEADER.Machine],
                compile_time=time.ctime(pe.FILE_HEADER.TimeDateStamp),
                entry_point=hex(pe.OPTIONAL_HEADER.AddressOfEntryPoint),
                sections=sections,
                imports=imports,
                exports=exports,
                signatures=signatures,
                packer_detection=packers
            )
            
        except Exception as e:
            self.logger.error(f"PE analysis failed: {e}")
            return PEInfo(is_pe=False)

    def _analyze_signatures(self, pe) -> List[Dict]:
        """Analyze digital signatures in PE file"""
        signatures = []
        try:
            for cert in pe.DIRECTORY_ENTRY_SECURITY:
                signatures.append({
                    "serial_number": cert.serial_number,
                    "issuer": cert.issuer,
                    "subject": cert.subject,
                    "valid_from": cert.valid_from,
                    "valid_to": cert.valid_to
                })
        except Exception:
            pass
        return signatures

    def _detect_packers(self, pe) -> List[str]:
        """Detect potential packers used on the PE file"""
        packers = []
        
        # Common packer section names
        packer_sections = {
            "UPX": [".UPX", "UPX"],
            "ASPack": [".aspack", "ASPack"],
            "PECompact": [".PECOMPACT"],
            "FSG": ["FSG"],
            "MPRESS": [".MPRESS1", ".MPRESS2"]
        }
        
        for section in pe.sections:
            name = section.Name.decode().rstrip('\x00')
            for packer, signatures in packer_sections.items():
                if any(sig in name for sig in signatures):
                    packers.append(packer)
        
        return list(set(packers))

    def _analyze_strings(self, file_path: str) -> Dict:
        """Extract and analyze strings from the file"""
        strings_output = subprocess.check_output(["strings", file_path]).decode()
        strings = strings_output.split('\n')
        
        # Categorize strings
        analysis = {
            "urls": [],
            "ip_addresses": [],
            "file_paths": [],
            "registry_keys": [],
            "api_calls": [],
            "suspicious_strings": [],
            "all_strings": strings
        }
        
        for string in strings:
            if "http://" in string or "https://" in string:
                analysis["urls"].append(string)
            elif "HKEY_" in string:
                analysis["registry_keys"].append(string)
            elif ".dll" in string.lower() or ".sys" in string.lower():
                analysis["api_calls"].append(string)
            # Add more categorization rules
            
        return analysis

    def _analyze_behavior(self, file_path: str) -> BehaviorAnalysis:
        """Analyze file behavior in a controlled environment"""
        # This would typically involve running the file in a sandbox
        # For this example, we'll return placeholder data
        return BehaviorAnalysis(
            file_operations=[],
            registry_operations=[],
            process_operations=[],
            network_connections=[],
            api_calls=[],
            suspicious_behaviors=[]
        )

    def _analyze_network_activity(self, file_path: str) -> List[NetworkActivity]:
        """Analyze network activity associated with the file"""
        # This would typically involve monitoring network traffic
        # For this example, we'll return an empty list
        return []

    def _check_threat_intelligence(self, file_path: str) -> Dict:
        """Check file against threat intelligence sources"""
        file_info = self._get_file_info(file_path)
        results = {
            "virustotal": None,
            "alienvault": None,
            "malware_bazaar": None
        }
        
        # Example VirusTotal check (requires API key)
        try:
            vt_api_key = os.getenv("VIRUSTOTAL_API_KEY")
            if vt_api_key:
                response = requests.get(
                    f"https://www.virustotal.com/vtapi/v2/file/report",
                    params={"apikey": vt_api_key, "resource": file_info.sha256}
                )
                if response.status_code == 200:
                    results["virustotal"] = response.json()
        except Exception as e:
            self.logger.error(f"VirusTotal API check failed: {e}")
        
        return results

    def _generate_report(self, results: Dict):
        """Generate comprehensive analysis report"""
        report_file = self.output_dir / f"report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        # Create report directory if it doesn't exist
        report_file.parent.mkdir(parents=True, exist_ok=True)
        
        # Write JSON report
        with open(report_file, "w") as f:
            json.dump(results, f, indent=4, default=str)
        
        # Generate HTML report
        self._generate_html_report(results)
        
        self.logger.info(f"Analysis report generated: {report_file}")

    def _generate_html_report(self, results: Dict):
        """Generate HTML report with styling"""
        html_file = self.output_dir / f"report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
        
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Malware Analysis Report</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .section {{ margin: 20px 0; padding: 10px; border: 1px solid #ddd; }}
                .high-risk {{ background-color: #ffebee; }}
                .medium-risk {{ background-color: #fff3e0; }}
                .low-risk {{ background-color: #e8f5e9; }}
                table {{ width: 100%; border-collapse: collapse; }}
                th, td {{ padding: 8px; text-align: left; border: 1px solid #ddd; }}
                th {{ background-color: #f5f5f5; }}
            </style>
        </head>
        <body>
            <h1>Malware Analysis Report</h1>
            <div class="section">
                <h2>File Information</h2>
                <table>
                    <tr><th>Property</th><th>Value</th></tr>
                    <tr><td>File Path</td><td>{results['file_info'].path}</td></tr>
                    <tr><td>Size</td><td>{results['file_info'].size:,} bytes</td></tr>
                    <tr><td>MD5</td><td>{results['file_info'].md5}</td></tr>
                    <tr><td>SHA256</td><td>{results['file_info'].sha256}</td></tr>
                    <tr><td>File Type</td><td>{results['file_info'].file_type}</td></tr>
                </table>
            </div>
        """
        
        # Add YARA matches section
        if results['yara_matches']:
            html_content += """
            <div class="section high-risk">
                <h2>YARA Matches</h2>
                <table>
                    <tr><th>Rule</th><th>Tags</th><th>Description</th></tr>
            """
            for match in results['yara_matches']:
                html_content += f"""
                    <tr>
                        <td>{match['rule_name']}</td>
                        <td>{', '.join(match['tags'])}</td>
                        <td>{match.get('meta', {}).get('description', 'N/A')}</td>
                    </tr>
                """
            html_content += "</table></div>"
        
        # Add PE analysis section if applicable
        if results['pe_analysis'].is_pe:
            html_content += f"""
            <div class="section">
                <h2>PE File Analysis</h2>
                <table>
                    <tr><td>Machine Type</td><td>{results['pe_analysis'].machine_type}</td></tr>
                    <tr><td>Compile Time</td><td>{results['pe_analysis'].compile_time}</td></tr>
                    <tr><td>Entry Point</td><td>{results['pe_analysis'].entry_point}</td></tr>
                </table>
                
                <h3>Sections</h3>
                <table>
                    <tr><th>Name</th><th>Virtual Address</th><th>Virtual Size</th><th>Raw Size</th><th>Entropy</th></tr>
            """
            for section in results['pe_analysis'].sections:
                html_content += f"""
                    <tr>
                        <td>{section['name']}</td>
                        <td>{section['virtual_address']}</td>
                        <td>{section['virtual_size']}</td>
                        <td>{section['raw_size']}</td>
                        <td>{section['entropy']:.2f}</td>
                    </tr>
                """
            html_content += "</table></div>"
        
        # Add strings analysis section
        html_content += """
            <div class="section">
                <h2>Strings Analysis</h2>
                <h3>URLs Found</h3>
                <ul>
        """
        for url in results['strings_analysis']['urls']:
            html_content += f"<li>{url}</li>"
        html_content += "</ul></div>"
        
        # Close HTML
        html_content += """
        </body>
        </html>
        """
        
        with open(html_file, "w") as f:
            f.write(html_content)

def main():
    import argparse
    parser = argparse.ArgumentParser(description="Advanced Malware Analysis Tool")
    parser.add_argument("target", help="File or directory to analyze")
    parser.add_argument("-o", "--output", default="analysis_results",
                       help="Output directory for analysis results")
    parser.add_argument("-v", "--verbose", action="store_true",
                       help="Enable verbose output")
    args = parser.parse_args()
    
    analyzer = MalwareAnalyzer(args.target, args.output, args.verbose)
    
    if os.path.isfile(args.target):
        results = analyzer.analyze_file(args.target)
        print(f"Analysis complete. Check {args.output} for detailed reports.")
    elif os.path.isdir(args.target):
        with ThreadPoolExecutor() as executor:
            for root, _, files in os.walk(args.target):
                for file in files:
                    file_path = os.path.join(root, file)
                    executor.submit(analyzer.analyze_file, file_path)
        print(f"Batch analysis complete. Check {args.output} for detailed reports.")
    else:
        print("Error: Target path does not exist")
        sys.exit(1)

if __name__ == "__main__":
    main()
